const std = @import("std");
const ArrayList = std.ArrayList;
const mem = std.mem;
const print = std.debug.print;
const file_utils = @import("../utils/file_utils.zig");
const process_utils = @import("../utils/process_utils.zig");
const errors = @import("../errors.zig");

/// Handle the build command
pub fn handleBuildCommand(allocator: std.mem.Allocator, clean_build: bool, sign_package: bool) !void {
    if (clean_build) {
        print("Cleaning previous builds...\n", .{});
        file_utils.cleanBuildDirectory();
    }

    print("Building package with paru...\n", .{});

    var build_args = ArrayList([]const u8).init(allocator);
    defer build_args.deinit();

    try build_args.appendSlice(&.{ "paru", "-B", "--noconfirm", "./" });
    if (sign_package) {
        try build_args.append("--sign");
    }

    // Set up environment variables for ccache
    const env_vars = [_][2][]const u8{
        .{ "CCACHE_DIR", "/home/builder/.ccache" },
    };

    try process_utils.runCommandWithEnv(allocator, build_args.items, &env_vars);
    print("Build completed successfully!\n", .{});

    try validateAndReportPackages(allocator);
}

/// Validate and report generated packages
fn validateAndReportPackages(allocator: std.mem.Allocator) !void {
    const patterns = [_][]const u8{".pkg.tar."};
    var package_files = try file_utils.findFilesWithPatterns(allocator, &patterns);
    defer {
        for (package_files.items) |file| {
            allocator.free(file);
        }
        package_files.deinit();
    }

    if (package_files.items.len == 0) {
        print(
            \\No package file (*.pkg.tar.*) was generated by paru.
            \\
            \\This usually means:
            \\• The build was skipped (e.g. due to existing src/ or pkg/ directories)
            \\• The PKGBUILD has a conditional 'exit 0'
            \\• paru failed silently (check logs above)
            \\• Dynamic pkgver/pkgrel caused unexpected naming
            \\
            \\Please review the build output carefully for warnings or skipped steps.
            \\
        , .{});
        return errors.BuilderError.NoPackagesGenerated;
    }

    // Sort package files for consistent output
    std.sort.pdq([]const u8, package_files.items, {}, struct {
        fn lessThan(_: void, lhs: []const u8, rhs: []const u8) bool {
            return mem.lessThan(u8, lhs, rhs);
        }
    }.lessThan);

    print("Successfully built {d} package(s): ", .{package_files.items.len});
    for (package_files.items, 0..) |pkg, i| {
        if (i > 0) print(", ", .{});
        print("{s}", .{pkg});
    }
    print("\n", .{});

    // List package details
    try listPackageDetails(allocator, package_files.items);
}

/// List details of generated packages
fn listPackageDetails(allocator: std.mem.Allocator, packages: []const []const u8) !void {
    var ls_args = ArrayList([]const u8).init(allocator);
    defer ls_args.deinit();
    try ls_args.append("ls");
    try ls_args.append("-la");
    try ls_args.appendSlice(packages);

    process_utils.runCommand(allocator, ls_args.items) catch |err| {
        print("Warning: could not run 'ls' on generated packages: {}\n", .{err});
    };
}
